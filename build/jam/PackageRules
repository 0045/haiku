#-------------------------------------------------------------------------------
# Packages for OBOS alpha/beta testers
#-------------------------------------------------------------------------------

rule Copy
{
	if $(2) {
		SEARCH on $(2) += $(SEARCH_SOURCE) ;
		Depends $(1) : <build>copyattr $(2) ;
		Copy1 $(1) : <build>copyattr $(2) ;
	}
}

actions Copy1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	"$(2[1])" -d "$(2[2-])" "$(1)"
}

rule Packages
{
	local packagenames = $(1) ;
	local packagefiles = $(2) ;
	local path = $(3) ;
	for name in $(packagenames) {
		Package $(name) : $(packagefiles) : $(path) ;
    }
}

rule FPackageConfigSubPath
{
	# FPackageConfigSubPath <packagename>
	#
	local packagename = $(1) ;

	local configSubPath ;
	on $(packagename) {
		if $(PLATFORM) = host {
			configSubPath = $(HOST_PLATFORM) $(HOST_ARCH) ;
		} else {
			configSubPath = $(TARGET_PLATFORM) $(TARGET_ARCH) ;
		}

		if $(DEBUG) = 0 {
			configSubPath += release ;
		} else {
			configSubPath += debug_$(DEBUG) ;
		}
	}

	return $(configSubPath) ;
}

rule Package
{
	local packagename = $(1) ;
    local packagefiles = $(2) ;
	local path = $(3) ;

	local configSubPath = [ FPackageConfigSubPath $(packagename) ] ;
	local packagezip = $(packagename:S=.zip:G=_packages) ;
	local targetDir = [ FDirName $(HAIKU_PACKAGE_DIR) $(configSubPath) ] ;
	local packagedir = [ FDirName $(targetDir) $(packagename) ] ;

    local installscript = install.sh ;
	local packageinstallscript = $(installscript:G=_packages!$(packagename)) ;
    local installzip = install.zip ;
	local packageinstallzip = $(installzip:G=_packages!$(packagename)) ;

    local packageobjectdir = [ FDirName $(HAIKU_PACKAGE_OBJECT_DIR)
		$(configSubPath) $(packagename) ] ;
	local packagefiledir =  [ FDirName $(packageobjectdir) $(path) ] ;
    local packagefileinstallzip
    	= $(installzip:G=_package_objects!$(packagename)) ;

	# add the files to the install.zip
	local packagefilegrist = [ FGrist _package_files $(packagename) $(path) ] ;
    for file in $(packagefiles) {
		if $(path[0]) = "boot" {
			local packagefile = $(file:G=$(packagefilegrist)) ;
			MakeLocate $(packagefile) : $(packagefiledir) ;
			Copy $(packagefile) : $(file) ;
			Clean cleanPackages : $(packagefile) ;
			PackageInstallZip $(packagefileinstallzip) : $(packagefile) ;
		} else {
			local packagefile = $(file:G=_packages!$(packagename)) ;
			MakeLocate $(packagefile) : $(packagedir) ;
			Copy $(packagefile) : [ FGristFiles $(file) ] ;
			Clean cleanPackages : $(packagefile) ;
			Depends $(packagezip) : $(packagefile) ;
		}
	}

	# general setup for this package -- only on first invocation
	if ! $(_setup_$(packagename)) {
		_setup_$(packagename) = true ;

		NotFile $(packagename) ;
		LocalDepends packages : $(packagename) ;

		MakeLocate $(packagezip) : $(targetDir) ;
		MakeLocate $(packageinstallscript) : $(packagedir) ;
		MakeLocate $(packageinstallzip) : $(packagedir) ;
		MakeLocate $(packagefileinstallzip) : $(packageobjectdir) ;

		PackageInstallScript $(packageinstallscript) : $(packagedir) ;
		LinkInstallZip $(packageinstallzip) : $(packagefileinstallzip) ;
		Depends $(packagename) : $(packagezip) ;
		PackageZip $(packagezip) : $(packagedir)
			: $(packageinstallscript) $(packageinstallzip) ;
	}

}

rule PackageSymLink
{
	# PackageSymLink <packageName> : <symlink path components>
	#	: <symlink target>
	#
	local packagename = $(1) ;
	local symlinkPath = $(2) ;
	local symlinkTarget = $(3) ;

	local configSubPath = [ FPackageConfigSubPath $(packagename) ] ;

	local symlinkDir = [ FReverse $(symlinkPath) ] ;
	local symlink = $(symlinkDir[1]) ;
	symlinkDir = [ FReverse $(symlinkDir[2-]) ] ;
	local symlinkGrist = [ FGrist _package $(packagename) $(symlinkDir) ] ;
	symlink = $(symlink:G=$(symlinkGrist)) ;

	if $(symlinkDir[1]) = boot {
	    local installzip = install.zip ;
	    local packagefileinstallzip
    		= $(installzip:G=_package_objects!$(packagename)) ;

		local packageobjectdir = [ FDirName $(HAIKU_PACKAGE_OBJECT_DIR)
			$(configSubPath) $(packagename) ] ;
		symlinkDir = [ FDirName $(packageobjectdir) $(symlinkDir) ] ;

		PackageInstallZip $(packagefileinstallzip) : $(symlink) ;

	} else {
		local packagezip = $(packagename:S=.zip:G=_packages) ;

		local packagedir = [ FDirName $(HAIKU_PACKAGE_DIR) $(configSubPath)
			$(packagename) ] ;
		symlinkDir = [ FDirName $(packagedir) $(symlinkDir) ] ;

		Depends $(packagezip) : $(symlink) ;
	}

	MakeLocate $(symlink) : $(symlinkDir) ;
	SymLink $(symlink) : $(symlinkTarget) : false ;
	Clean cleanPackages : $(symlink) ;
}

rule PackageDriverSymLink
{
	# PackageDriverSymLink <packageName> : <devRelativeSymlinkComponents> ;
	# <packageName>: Package name.
	# <devRelativeSymlinkComponents>: Path components relative to the
	#     /boot/home/config/add-ons/kernel/drivers/dev directory, e.g.
	#     "graphics mga.driver" (no quotation, of course).
	#
	local packageName = $(1) ;
	local symlinkComponents = $(2) ;

	# construct the symlink contents
	local symlinkPath = [ FReverse $(symlinkComponents) ] ;
	symlinkPath = bin $(symlinkPath[1]) ;

	for i in $(symlinkComponents) {
		symlinkPath = $(DOTDOT) $(symlinkPath) ;
	}

	PackageSymLink $(packageName)
		: boot home config add-ons kernel drivers dev $(symlinkComponents)
		: [ FDirName $(symlinkPath) ] ;
}

rule PackageZip
{
	local dir = $(2:G=dir) ;
	Depends $(1) : $(dir) $(3) ;
	Clean cleanPackages : $(1) ;
	PackageZip1 $(1) : $(dir) ;
}

actions together PackageZip1 {
	cd "$(2:P)" ;
	zip -rq "$(1:BS)" "$(2:BS)" ;
}

rule PackageInstallScript
{
	MakeLocate $(1) : $(2) ;
	Clean cleanPackages : $(1) ;
	PackageInstallScript1 $(1) : $(2:G=dir) ;
}

actions together PackageInstallScript1
{
echo '#!/bin/sh
base=`dirname "$0"`
cd "$base"
if [ -n "$TTY" ]
then
    unzip -d / install.zip
else
    response=`alert "Would you like to automatically overwrite existing files, or receive a prompt?" "Overwrite" "Prompt"`
    if [ $response == "Overwrite" ]
    then
        unzip -od / install.zip
        alert "Finished installing" "Thanks"
    else
        if [ -e /boot/beos/apps/Terminal ]
        then
            terminal=/boot/beos/apps/Terminal
        else
            terminal=`query Terminal | head -1`
        fi
        $terminal -t "installer" /bin/sh "$0"
    fi
fi' > "$(1)" ;
	chmod 755 "$(1)" ;
}

rule PackageInstallZip
{
	Depends $(1) : $(2) ;
	Clean cleanPackages : $(1) ;
}

actions together PackageInstallZip
{
	cd "$(1:P)" ;
	zip -rqy "$(1:BS)" boot ;
}

rule LinkInstallZip
{
	Depends $(1) : $(2) ;
	Clean cleanPackages : $(1) ;
}

actions together LinkInstallZip
{
	ln -sf "`pwd`/$(2)" "$(1)" ;
}


# TODO: The stuff above should be moved (Copy) or removed (the rest).


#pragma mark - Haiku Packages


rule FHaikuPackageGrist package
{
	local grist = [ Match "<(.*)>" : $(package:G) ] ;
	return hpkg_$(grist:E="")_$(package:G=) ;
}


rule HaikuPackage package
{
	local grist = [ FHaikuPackageGrist $(package) ] ;

	HAIKU_CONTAINER_GRIST on $(package) = $(grist) ;
	HAIKU_INCLUDE_IN_CONTAINER_VAR on $(package) = HAIKU_INCLUDE_IN_PACKAGES ;
	HAIKU_INSTALL_TARGETS_VAR on $(package)
		= $(grist)_HAIKU_PACKAGE_INSTALL_TARGETS ;
	HAIKU_CONTAINER_SYSTEM_DIR_TOKENS on $(package) = ;

	HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE = $(package) ;

	if $(HAIKU_PACKAGES_UPDATE_ONLY) {
		HAIKU_CONTAINER_UPDATE_ONLY on $(package) = 1 ;
		HAIKU_CONTAINER_INHERIT_UPDATE_VARIABLE on $(package)
			= HAIKU_INCLUDE_IN_IMAGE ;
	} else if $(HAIKU_UPDATE_ALL_PACKAGES) {
		HAIKU_INCLUDE_IN_IMAGE on $(package) = 1 ;
	}

	HAIKU_CONTAINER_ALWAYS_CREATE_DIRECTORIES on $(package) = 1 ;
}


rule BuildHaikuPackage package : packageInfo
{
	local grist = [ FHaikuPackageGrist $(package) ] ;

	local tempDir = [ FDirName $(HAIKU_PACKAGES_BUILD_DIR) $(grist) ] ;
	local scriptDir = [ FDirName $(tempDir) scripts ] ;

	# locate the package and package info
	MakeLocate $(package) : $(HAIKU_PACKAGES_DIR) ;
	SEARCH on $(packageInfo) += $(HAIKU_PACKAGE_INFOS_DIR) ;
	LocalDepends $(package) : $(packageInfo) ;

	# prepare the script that initializes the shell variables
	local initVariablesScript = <$(grist)>haiku.package-init-vars ;
	MakeLocate $(initVariablesScript) : $(scriptDir) ;
	Always $(initVariablesScript) ;

	local script = $(initVariablesScript) ;
	AddVariableToScript $(script) : sourceDir : $(HAIKU_TOP) ;
	AddVariableToScript $(script) : outputDir : $(HAIKU_OUTPUT_DIR) ;
	AddVariableToScript $(script) : tmpDir : $(tempDir) ;
	AddVariableToScript $(script) : addBuildCompatibilityLibDir
		: $(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR) ;
	AddVariableToScript $(script) : updateOnly
		: [ on $(package) return $(HAIKU_CONTAINER_UPDATE_ONLY) ] ;
	AddTargetVariableToScript $(script) : <build>addattr ;
	AddTargetVariableToScript $(script) : <build>copyattr ;
	AddTargetVariableToScript $(script) : <build>package ;
	AddTargetVariableToScript $(script) : <build>rc ;
	AddTargetVariableToScript $(script) : <build>resattr ;
	AddTargetVariableToScript $(script) : <build>unzip ;
	if $(HOST_RM_ATTRS_TARGET) {
		AddTargetVariableToScript $(script) : $(HOST_RM_ATTRS_TARGET)
			: rmAttrs ;
	} else {
		AddVariableToScript $(script) : rmAttrs : rm ;
	}

	# create the other scripts
	local makeDirsScript = <$(grist)>haiku.package-make-dirs ;
	local copyFilesScript = <$(grist)>haiku.package-copy-files ;

	MakeLocate $(makeDirsScript) $(copyFilesScript) : $(scriptDir) ;

	CreateContainerMakeDirectoriesScript $(package) : $(makeDirsScript) ;
	CreateContainerCopyFilesScript $(package) : $(copyFilesScript) ;

	local scripts = $(initVariablesScript) $(makeDirsScript)
		$(copyFilesScript) ;

	# call the build actions
	local mainScript = build_haiku_package ;
	SEARCH on $(mainScript) = [ FDirName $(HAIKU_TOP) build scripts ] ;

	LocalDepends $(package) : $(mainScript) $(scripts) ;
	BuildHaikuPackage1 $(package) : $(mainScript) $(packageInfo) $(scripts) ;
}


actions BuildHaikuPackage1
{
	$(2[1]) "$(1)" "$(2[2])" $(2[3-])
}


rule AddDirectoryToPackage directoryTokens : attributeFiles
{
	return [ AddDirectoryToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(directoryTokens) : $(attributeFiles) ] ;
}


rule AddFilesToPackage directory : targets : destName
{
	AddFilesToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE) : $(directory)
		: $(targets) : $(destName) ;
}


rule AddSymlinkToPackage directoryTokens : linkTarget : linkName
{
	linkTarget = $(linkTarget:J=/) ;

	AddSymlinkToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(directoryTokens) : $(linkTarget) : $(linkName) ;
}


rule CopyDirectoryToPackage directoryTokens : sourceDirectory
	: targetDirectoryName : excludePatterns : flags
{
	CopyDirectoryToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(directoryTokens) : $(sourceDirectory) : $(targetDirectoryName)
		: $(excludePatterns) : $(flags) ;
}


rule AddHeaderDirectoryToPackage dirTokens : dirName : flags
{
	AddHeaderDirectoryToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(dirTokens) : $(dirName) : $(flags) ;
}


rule AddWifiFirmwareToPackage driver : subDirToExtract : archive
	: extract
{
	AddWifiFirmwareToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(driver) : $(subDirToExtract) : $(archive) : $(extract) ;
}


rule ExtractArchiveToPackage dirTokens : archiveFile : flags : extractedSubDir
{
	ExtractArchiveToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(dirTokens) : $(archiveFile) : $(flags) : $(extractedSubDir) ;
}


rule AddDriversToPackage relativeDirectoryTokens : targets
{
	AddDriversToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(relativeDirectoryTokens) : $(targets) ;
}


rule AddNewDriversToPackage relativeDirectoryTokens : targets
{
	AddNewDriversToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(relativeDirectoryTokens) : $(targets) ;
}


rule AddBootModuleSymlinksToPackage targets
{
	AddBootModuleSymlinksToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(targets) ;
}


rule AddLibrariesToPackage directory : libs
{
	AddLibrariesToContainer $(HAIKU_CURRENTLY_BUILT_HAIKU_PACKAGE)
		: $(directory) : $(libs) ;
}
