rule PackageFamily packageBaseName
{
	return $(packageBaseName:G=package-family) ;
}


rule AddRepositoryPackage repository : architecture : baseName : version
{
	local package = $(baseName)-$(version) ;
	package = $(package:E=$(baseName):G=package-in-$(repository:G=)) ;
	HAIKU_PACKAGE_REPOSITORY on $(package) = $(repository) ;
	HAIKU_PACKAGE_ARCHITECTURE on $(package) = $(architecture) ;
	HAIKU_PACKAGE_FILE_NAME on $(package) = $(package:G=)-$(architecture).hpkg ;

	if ! $(baseName) in $(HAIKU_AVAILABLE_PACKAGES) {
		HAIKU_AVAILABLE_PACKAGES += $(baseName) ;
	}

	local packageFamily = [ PackageFamily $(baseName) ] ;
	HAIKU_PACKAGE_VERSIONS on $(packageFamily) += $(package) ;
	HAIKU_REPOSITORY_PACKAGES on $(repository) += $(package) ;
}


rule AddRepositoryPackages repository : architecture : packages : sourcePackages
	: debugInfoPackages
{
	local package ;
	for package in $(packages) {
		local splitName = [ Match "([^-]*)-(.*)" : $(package) ] ;
		local baseName = $(splitName[1]:E=$(package)) ;
		local version = $(splitName[2]) ;
		AddRepositoryPackage $(repository) : $(architecture) : $(baseName)
			: $(version) ;
		if $(baseName) in $(sourcePackages) {
			AddRepositoryPackage $(repository) : source : $(baseName)_source
				: $(version) ;
		}
		if $(baseName) in $(debugInfoPackages) {
			AddRepositoryPackage $(repository) : $(architecture)
				: $(baseName)_debuginfo : $(version) ;
		}
	}
}


rule PackageRepository repository : architecture : repositoryUrl : anyPackages
	: packages : sourcePackages : debugInfoPackages
{
	repository = $(repository:G=repository) ;

	if $(architecture) != $(HAIKU_PACKAGING_ARCH) {
		return ;
	}

	HAIKU_REPOSITORIES += $(repository) ;
	HAIKU_REPOSITORY_URL on $(repository) = $(repositoryUrl) ;
	HAIKU_REPOSITORY_DEFINITION_FILE on $(repository)
		= $(HAIKU_REPOSITORY_JAMFILE) ;

	AddRepositoryPackages $(repository) : any : $(anyPackages)
		: $(sourcePackages) : $(debugInfoPackages) ;
	AddRepositoryPackages $(repository) : $(architecture) : $(packages)
		: $(sourcePackages) : $(debugInfoPackages) ;

	# build package list file
	local packageListFile = $(repository:G=repository-package-list)-packages ;
	MakeLocate $(packageListFile) : $(HAIKU_PACKAGE_REPOSITORIES_DIR) ;
	GeneratedRepositoryPackageList $(packageListFile) : $(repository) ;

	# build package list checksum file
	local packagesChecksumFile
		= $(repository:G=repository-package-checksum)-checksum ;
	MakeLocate $(packagesChecksumFile) : $(HAIKU_PACKAGE_REPOSITORIES_DIR) ;
	Depends $(packagesChecksumFile) : $(packageListFile) ;
	ChecksumFileSHA256 $(packagesChecksumFile) : $(packageListFile) ;

	# download repository info file
	local repositoryInfo = $(repository:G=repository-info)-info ;
	MakeLocate $(repositoryInfo) : $(HAIKU_PACKAGE_REPOSITORIES_DIR) ;
	local repoUrl = [ on $(repository) return $(HAIKU_REPOSITORY_URL) ] ;
	DownloadLocatedFile $(repositoryInfo)
		: "$(repoUrl)/`cat $source`/repo.info"
		: $(packagesChecksumFile) ;

	# download repository file
	local repositoryFile = $(repository:G=repository-cache) ;
	MakeLocate $(repositoryFile) : $(HAIKU_PACKAGE_REPOSITORIES_DIR) ;
	local repoUrl = [ on $(repository) return $(HAIKU_REPOSITORY_URL) ] ;
	DownloadLocatedFile $(repositoryFile)
		: "$(repoUrl)/`cat $source`/repo"
		: $(packagesChecksumFile) ;

	# build repository config file
	local repositoryConfig = $(repository:G=repository-config)-config ;
	MakeLocate $(repositoryConfig) : $(HAIKU_PACKAGE_REPOSITORIES_DIR) ;
	RepositoryConfig $(repositoryConfig) : $(repositoryInfo)
		: $(packagesChecksumFile) : $(repository) ;

	HAIKU_REPOSITORY_CACHE_FILE on $(repository) = $(repositoryFile) ;
	HAIKU_REPOSITORY_CONFIG_FILE on $(repository) = $(repositoryConfig) ;
	HAIKU_REPOSITORY_PACKAGES_CHECKSUM_FILE on $(repository)
		= $(packagesChecksumFile) ;
}


rule GeneratedRepositoryPackageList target : repository
{
	repository = $(repository:G=repository) ;

	# construct a list of file names
	local fileNames ;
	local package ;
	for package in [ on $(repository) return $(HAIKU_REPOSITORY_PACKAGES) ] {
		fileNames += [ on $(package) return $(HAIKU_PACKAGE_FILE_NAME) ] ;
	}

	local definitionFile
		= [ on $(repository) return $(HAIKU_REPOSITORY_DEFINITION_FILE) ] ;
	Depends $(target) : $(definitionFile) ;

	HAIKU_REPOSITORY_PACKAGE_FILE_NAMES on $(target) = $(fileNames) ;
	GeneratedRepositoryPackageList1 $(target) ;
}


actions GeneratedRepositoryPackageList1
{
	(for file in $(HAIKU_REPOSITORY_PACKAGE_FILE_NAMES) ; do
		echo $file
	done) | LC_ALL=C sort -u > $(1)
}


rule RepositoryConfig repoConfig : repoInfo : packagesChecksumFile : repository
{
	repository = $(repository:G=repository) ;

	HAIKU_REPOSITORY_URL on $(repoConfig)
		= [ on $(repository) return $(HAIKU_REPOSITORY_URL) ] ;
	Depends $(repoConfig)
		: <build>create_repository_config $(repoInfo) $(packagesChecksumFile) ;
	RepositoryConfig1 $(repoConfig)
		: <build>create_repository_config $(repoInfo) $(packagesChecksumFile) ;
}


actions RepositoryConfig1
{
	$(HOST_ADD_BUILD_COMPATIBILITY_LIB_DIR)
	$(2[1]) $(HAIKU_REPOSITORY_URL)/`cat $(2[3])` $(2[2]) $(1)
}


rule IsPackageAvailable package
{
	if $(package) in $(HAIKU_AVAILABLE_PACKAGES) {
		return 1 ;
	}

	return ;
}


rule DownloadPackage packageName
{
	if ! [ IsPackageAvailable $(packageName) ] {
		Exit "DownloadPackage: package" $(packageName) "not available!" ;
		return ;
	}

	# TODO: We should support explicitly specified versions (or partial/minimum
	# versions like gcc-2 or gcc-4).

	local packageFamily = [ PackageFamily $(packageName) ] ;
	local package
		= [ on $(packageFamily) return $(HAIKU_PACKAGE_VERSIONS[1]) ] ;
	local fileName = [ on $(package) return $(HAIKU_PACKAGE_FILE_NAME) ] ;
	local repository = [ on $(package) return $(HAIKU_PACKAGE_REPOSITORY) ] ;
	local baseUrl = [ on $(repository) return $(HAIKU_REPOSITORY_URL) ] ;
	local packagesChecksumFile
		= [ on $(repository)
			return $(HAIKU_REPOSITORY_PACKAGES_CHECKSUM_FILE) ] ;

	local downloadedFile = [ DownloadFile $(fileName)
		: "$(baseUrl)/`cat $source`/packages/$(fileName)"
		: $(packagesChecksumFile) ] ;
	NoUpdate $(downloadedFile) ;
		# Don't download the file again when something in the repository
		# changes. It is (supposed to be) still the same file.
	return $(downloadedFile) ;
}
